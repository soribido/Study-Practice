<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MRP Value Iteration Visualization</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            background-color: #f0f0f0;
        }
        
        h1 {
            color: #333;
            margin-bottom: 10px;
        }
        
        #controls {
            margin: 20px 0;
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        button {
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            transition: background-color 0.3s;
        }
        
        button:hover {
            background-color: #45a049;
        }
        
        button:active {
            background-color: #3d8b40;
        }
        
        #reset {
            background-color: #f44336;
        }
        
        #reset:hover {
            background-color: #da190b;
        }
        
        #info {
            font-size: 18px;
            font-weight: bold;
            color: #333;
            margin: 10px 0;
        }
        
        canvas {
            border: 2px solid #333;
            background-color: white;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        
        #gamma-control {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        input[type="range"] {
            width: 150px;
        }
    </style>
</head>
<body>
    <h1>MRP Value Iteration Visualization</h1>
    <div id="info">Iteration: 0 | γ = 1.00</div>
    
    <div id="controls">
        <button id="next">Next Iteration</button>
        <button id="iter10">+10 Iterations</button>
        <button id="iter100">+100 Iterations</button>
        <button id="reset">Reset</button>
        <div id="gamma-control">
            <label>γ:</label>
            <input type="range" id="gamma" min="0" max="100" value="100" step="1">
            <span id="gamma-value">1.00</span>
        </div>
    </div>
    
    <canvas id="canvas" width="900" height="600"></canvas>
    
    <script>
        class MRPVisualizer {
            constructor() {
                this.canvas = document.getElementById('canvas');
                this.ctx = this.canvas.getContext('2d');
                this.gamma = 1.0;
                this.iteration = 0;
                
                // states
                this.states = {
                    's1': {pos: [150, 100], reward: -1, name: 's1', terminal: false, label: '-23'},
                    's2': {pos: [150, 300], reward: -2, name: 's2', terminal: false, label: '-13'},
                    's3': {pos: [400, 100], reward: 0, name: 's3', terminal: true, label: '0'},
                    's4': {pos: [400, 300], reward: -2, name: 's4', terminal: false, label: '1.5'},
                    's5': {pos: [600, 350], reward: -2, name: 's5', terminal: false, label: '4.3'},
                    's6': {pos: [750, 350], reward: 10, name: 's6', terminal: false, label: '10'},
                    's7': {pos: [400, 480], reward: 1, name: 's7', terminal: false, label: '0.8'}
                };
                
                // transitions
                this.transitions = {
                    's1': [['s1', 0.9], ['s2', 0.1]],
                    's2': [['s1', 0.5], ['s4', 0.5]],
                    's3': [['s3', 1.0]],
                    's4': [['s3', 0.2], ['s5', 0.8]],
                    's5': [['s6', 0.6], ['s7', 0.4]],
                    's6': [['s3', 1.0]],
                    's7': [['s2', 0.2], ['s4', 0.4], ['s5', 0.4]]
                };
                
                this.values = {};
                for (let s in this.states) {
                    this.values[s] = 0.0;
                }
                
                this.setupEventListeners();
                this.draw();
            }
            
            setupEventListeners() {
                document.getElementById('next').addEventListener('click', () => {
                    this.bellmanUpdate();
                    this.draw();
                });
                
                document.getElementById('iter10').addEventListener('click', () => {
                    for (let i = 0; i < 10; i++) this.bellmanUpdate();
                    this.draw();
                });
                
                document.getElementById('iter100').addEventListener('click', () => {
                    for (let i = 0; i < 100; i++) this.bellmanUpdate();
                    this.draw();
                });
                
                document.getElementById('reset').addEventListener('click', () => {
                    this.reset();
                });
                
                document.getElementById('gamma').addEventListener('input', (e) => {
                    this.gamma = e.target.value / 100;
                    document.getElementById('gamma-value').textContent = this.gamma.toFixed(2);
                    this.reset();
                });
            }
            
            bellmanUpdate() {
                let newValues = {};
                
                for (let state in this.states) {
                    if (this.states[state].terminal) {
                        newValues[state] = 0.0;
                    } else {
                        let reward = this.states[state].reward;
                        let expectedValue = 0.0;
                        
                        for (let [nextState, prob] of this.transitions[state]) {
                            expectedValue += prob * this.values[nextState];
                        }
                        
                        newValues[state] = reward + this.gamma * expectedValue;
                    }
                }
                
                this.values = newValues;
                this.iteration++;
                document.getElementById('info').textContent = 
                    `Iteration: ${this.iteration} | γ = ${this.gamma.toFixed(2)}`;
            }
            
            reset() {
                this.iteration = 0;
                for (let s in this.states) {
                    this.values[s] = 0.0;
                }
                document.getElementById('info').textContent = 
                    `Iteration: ${this.iteration} | γ = ${this.gamma.toFixed(2)}`;
                this.draw();
            }
            
            drawArrow(x1, y1, x2, y2, label) {
                const ctx = this.ctx;
                const headlen = 15;
                const dx = x2 - x1;
                const dy = y2 - y1;
                const angle = Math.atan2(dy, dx);
                
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                ctx.beginPath();
                ctx.moveTo(x2, y2);
                ctx.lineTo(x2 - headlen * Math.cos(angle - Math.PI / 6), 
                          y2 - headlen * Math.sin(angle - Math.PI / 6));
                ctx.lineTo(x2 - headlen * Math.cos(angle + Math.PI / 6), 
                          y2 - headlen * Math.sin(angle + Math.PI / 6));
                ctx.closePath();
                ctx.fillStyle = '#333';
                ctx.fill();
                
                const midX = (x1 + x2) / 2;
                const midY = (y1 + y2) / 2;
                ctx.fillStyle = 'white';
                ctx.fillRect(midX - 15, midY - 10, 30, 20);
                ctx.fillStyle = '#000';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(label, midX, midY);
            }
            
            drawSelfLoop(x, y, label) {
                const ctx = this.ctx;
                const radius = 30;
                
                ctx.beginPath();
                ctx.arc(x, y - 40, radius, 0.3 * Math.PI, 0.7 * Math.PI);
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 2;
                ctx.stroke();
                
                ctx.beginPath();
                ctx.moveTo(x - 25, y - 50);
                ctx.lineTo(x - 20, y - 60);
                ctx.lineTo(x - 30, y - 55);
                ctx.closePath();
                ctx.fillStyle = '#333';
                ctx.fill();
                
                ctx.fillStyle = '#000';
                ctx.font = '12px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(label, x, y - 75);
            }
            
            drawState(state, x, y) {
                const ctx = this.ctx;
                const radius = 35;
                
                if (this.states[state].terminal) {
                    ctx.fillStyle = '#e0e0e0';
                    ctx.fillRect(x - radius, y - radius, radius * 2, radius * 2);
                    ctx.strokeStyle = '#333';
                    ctx.lineWidth = 3;
                    ctx.strokeRect(x - radius, y - radius, radius * 2, radius * 2);
                } else {
                    ctx.beginPath();
                    ctx.arc(x, y, radius, 0, 2 * Math.PI);
                    ctx.fillStyle = '#add8e6';
                    ctx.fill();
                    ctx.strokeStyle = '#333';
                    ctx.lineWidth = 3;
                    ctx.stroke();
                }
                
                ctx.fillStyle = '#000';
                ctx.font = 'bold 16px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.values[state].toFixed(2), x, y);
                
                ctx.font = 'italic 12px Arial';
                ctx.fillText(`R = ${this.states[state].reward}`, x + 50, y + 20);
            }
            
            draw() {
                const ctx = this.ctx;
                ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                for (let fromState in this.transitions) {
                    const [x1, y1] = this.states[fromState].pos;
                    
                    for (let [toState, prob] of this.transitions[fromState]) {
                        if (fromState === toState) {
                            this.drawSelfLoop(x1, y1, prob.toFixed(1));
                        } else {
                            const [x2, y2] = this.states[toState].pos;
                            const angle = Math.atan2(y2 - y1, x2 - x1);
                            const offset = 40;
                            
                            const startX = x1 + offset * Math.cos(angle);
                            const startY = y1 + offset * Math.sin(angle);
                            const endX = x2 - offset * Math.cos(angle);
                            const endY = y2 - offset * Math.sin(angle);
                            
                            this.drawArrow(startX, startY, endX, endY, prob.toFixed(1));
                        }
                    }
                }
                
                for (let state in this.states) {
                    const [x, y] = this.states[state].pos;
                    this.drawState(state, x, y);
                }
            }
        }
        
        window.onload = () => {
            new MRPVisualizer();
        };
    </script>
</body>
</html>
